import numpy as np
from mesohops.dynamics.bath_corr_functions import bcf_exp
from mesohops.dynamics.hops_noise import HopsNoise

__title__ = "Test of hops_noise"
__author__ = "Jacob K. Lynd"
__version__ = "1.2"
__date__ = "July 7 2021"

# Test Noise Model
# ----------------
noise_param = {
    "SEED": 0,
    "MODEL": "FFT_FILTER",
    "TLEN": 10.0,  # Units: fs
    "TAU": 1.0,  # Units: fs
}

loperator = np.zeros([2, 2, 2], dtype=np.float64)
loperator[0, 0, 0] = 1.0
loperator[1, 1, 1] = 1.0
sys_param = {
    "HAMILTONIAN": np.array([[0, 10.0], [10.0, 0]], dtype=np.float64),
    "GW_SYSBATH": [[10.0, 10.0], [5.0, 5.0]],
    "L_HIER": loperator,
    "ALPHA_NOISE1": bcf_exp,
    "PARAM_NOISE1": [[10.0, 10.0], [5.0, 5.0]],
    "L_NOISE1": loperator,
}


sys_param["NSITE"] = len(sys_param["HAMILTONIAN"][0])
sys_param["NMODES"] = len(sys_param["GW_SYSBATH"][0])
sys_param["N_L2"] = 2
sys_param["L_IND_BY_NMODE1"] = [0, 1]
sys_param["LIND_DICT"] = {0: loperator[0, :, :], 1: loperator[1, :, :]}


def test_initialize():
    """
    Test the initialization of the HopsNoise class (via the FFTFilterNoise class,
    which inherits from it) and thus param, its setter, and the update_param function.
    """
    noise_param = {
        "SEED": None,
        "MODEL": "FFT_FILTER",
        "TLEN": 1000.0,  # Units: fs
        "TAU": 1.0,  # Units: fs,
        "INTERPOLATE": False
    }

    noise_corr_working = {
        "CORR_FUNCTION": sys_param["ALPHA_NOISE1"],
        "N_L2": sys_param["N_L2"],
        "LIND_BY_NMODE": sys_param["L_IND_BY_NMODE1"],
        "CORR_PARAM": sys_param["PARAM_NOISE1"],
    }

    noise_corr_empty = {}

    t_axis = np.arange(0, 1001.0, 1.0)

    # Initialize a) turns noise_param into HopsNoise.param and b) updates
    # HopsNoise.param with all the key, value pairs from noise_corr. Finally,
    # it builds the noise t_axis.

    # Test that initializaiton of a HopsNoise properly moves the parameters from
    # noise_param into the param dictionary and constructs the noise correlation
    # function
    test_noise = HopsNoise(noise_param, noise_corr_empty)

    assert noise_param['SEED'] == test_noise.param['SEED']
    assert noise_param['MODEL'] == test_noise.param['MODEL']
    assert noise_param['TLEN'] == test_noise.param['TLEN']
    assert noise_param['TAU'] == test_noise.param['TAU']
    assert noise_param['INTERPOLATE'] == test_noise.param['INTERPOLATE']
    assert np.allclose(t_axis, test_noise.param['T_AXIS'])

    # Now test that the param dictionary is updated with all items from the
    # noise_corr dictionary

    test_noise = HopsNoise(noise_param, noise_corr_working)

    assert noise_param['SEED'] == test_noise.param['SEED']
    assert noise_param['MODEL'] == test_noise.param['MODEL']
    assert noise_param['TLEN'] == test_noise.param['TLEN']
    assert noise_param['TAU'] == test_noise.param['TAU']
    assert noise_param['INTERPOLATE'] == test_noise.param['INTERPOLATE']
    assert np.allclose(t_axis, test_noise.param['T_AXIS'])
    assert noise_corr_working['CORR_FUNCTION'] == test_noise.param['CORR_FUNCTION']
    assert noise_corr_working['N_L2'] == test_noise.param['N_L2']
    assert noise_corr_working['LIND_BY_NMODE'] == test_noise.param['LIND_BY_NMODE']
    assert noise_corr_working['CORR_PARAM'] == test_noise.param['CORR_PARAM']
    # Test that the keys overlap excepting T_AXIS (added by HopsNoise) and
    # STORE_RAW_NOISE (added by FFTFilterNoise)
    assert set(list(noise_param.keys()) + list(noise_corr_working.keys()) + [
        'T_AXIS']) == set(
        test_noise.param.keys())


def test_get_noise():
    """
    Tests that the get_noise function properly fetches the noise.
    """
    noise_param = {
        "SEED": None,
        "MODEL": "FFT_FILTER",
        "TLEN": 1000.0,  # Units: fs
        "TAU": 1.0,  # Units: fs,
        "INTERPOLATE": False
    }

    noise_corr_working = {
        "CORR_FUNCTION": sys_param["ALPHA_NOISE1"],
        "N_L2": sys_param["N_L2"],
        "LIND_BY_NMODE": sys_param["L_IND_BY_NMODE1"],
        "CORR_PARAM": sys_param["PARAM_NOISE1"],
    }

    t_axis = np.arange(0, 1001.0, 1.0)
    test_noise = HopsNoise(noise_param, noise_corr_working)
    noise = np.ones([2,len(t_axis)])
    test_noise._noise = noise
    test_noise._lock()

    # Tests only that the get_noise function over the full noise time axis returns
    # the full noise. Does NOT test whether the noise is generated by the correct
    # formula.

    assert np.allclose(test_noise.get_noise(t_axis[:2])[0,:], test_noise._noise[0,:2])

def test_corr_func_builder():
    """
    Tests that the _corr_func_by_lop_taxis returns the correct correlation function.
    """
    noise_param = {
        "SEED": None,
        "MODEL": "FFT_FILTER",
        "TLEN": 1000.0,  # Units: fs
        "TAU": 1.0,  # Units: fs,
        "INTERPOLATE": False
    }

    noise_corr_working = {
        "CORR_FUNCTION": sys_param["ALPHA_NOISE1"],
        "N_L2": sys_param["N_L2"],
        "LIND_BY_NMODE": sys_param["L_IND_BY_NMODE1"],
        "CORR_PARAM": sys_param["PARAM_NOISE1"],
    }

    t_axis = np.arange(0, 1001.0, 1.0)
    test_noise = HopsNoise(noise_param, noise_corr_working)

    # Compares the correlation function over both sites calculated manually with the
    # correlation function over both sites generated by the FFTFilterNoise object.
    corr_func_site_0 = bcf_exp(t_axis, sys_param["PARAM_NOISE1"][0][0], sys_param[
        "PARAM_NOISE1"][0][1])
    corr_func_site_1 = bcf_exp(t_axis, sys_param["PARAM_NOISE1"][1][0], sys_param[
        "PARAM_NOISE1"][1][1])
    corr_func = np.array([corr_func_site_0, corr_func_site_1])
    assert np.allclose(corr_func, test_noise._corr_func_by_lop_taxis(t_axis))
